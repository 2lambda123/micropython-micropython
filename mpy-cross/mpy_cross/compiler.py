# This file is part of the MicroPython project, http://micropython.org/
#
# The MIT License (MIT)
#
# Copyright (c) 2022 Andrew Leech
# Copyright (c) 2023 Jim Mussared
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

__all__ = [
    "CrossCompileError",
    "Compiler",
    "default_compiler",
    "EMIT_BYTECODE",
    "EMIT_NATIVE",
    "EMIT_VIPER",
    "NATIVE_ARCH_NONE",
    "NATIVE_ARCH_X86",
    "NATIVE_ARCH_X64",
    "NATIVE_ARCH_ARMV6",
    "NATIVE_ARCH_ARMV6M",
    "NATIVE_ARCH_ARMV7M",
    "NATIVE_ARCH_ARMV7EM",
    "NATIVE_ARCH_ARMV7EMSP",
    "NATIVE_ARCH_ARMV7EMDP",
    "NATIVE_ARCH_XTENSA",
    "NATIVE_ARCH_XTENSAWIN",
    "NATIVE_ARCHS",
]


import os


class CrossCompileError(Exception):
    pass


class CompilerNotFoundError(Exception):
    pass


EMIT_BYTECODE = "bytecode"
EMIT_NATIVE = "native"
EMIT_VIPER = "viper"


def emit_id(name):
    return {
        EMIT_BYTECODE: 1,
        EMIT_NATIVE: 2,
        EMIT_VIPER: 3,
    }[name]


NATIVE_ARCH_NONE = ""
NATIVE_ARCH_X86 = "x86"
NATIVE_ARCH_X64 = "x64"
NATIVE_ARCH_ARMV6 = "armv6"
NATIVE_ARCH_ARMV6M = "armv6m"
NATIVE_ARCH_ARMV7M = "armv7m"
NATIVE_ARCH_ARMV7EM = "armv7em"
NATIVE_ARCH_ARMV7EMSP = "armv7emsp"
NATIVE_ARCH_ARMV7EMDP = "armv7emdp"
NATIVE_ARCH_XTENSA = "xtensa"
NATIVE_ARCH_XTENSAWIN = "xtensawin"

NATIVE_ARCHS = [
    NATIVE_ARCH_NONE,
    NATIVE_ARCH_X86,
    NATIVE_ARCH_X64,
    NATIVE_ARCH_ARMV6,
    NATIVE_ARCH_ARMV6M,
    NATIVE_ARCH_ARMV7M,
    NATIVE_ARCH_ARMV7EM,
    NATIVE_ARCH_ARMV7EMSP,
    NATIVE_ARCH_ARMV7EMDP,
    NATIVE_ARCH_XTENSA,
    NATIVE_ARCH_XTENSAWIN,
]


def native_arch_id(name):
    if name is None:
        return 0

    return {
        NATIVE_ARCH_NONE: 0,
        NATIVE_ARCH_X86: 1,
        NATIVE_ARCH_X64: 2,
        NATIVE_ARCH_ARMV6: 3,
        NATIVE_ARCH_ARMV6M: 4,
        NATIVE_ARCH_ARMV7M: 5,
        NATIVE_ARCH_ARMV7EM: 6,
        NATIVE_ARCH_ARMV7EMSP: 7,
        NATIVE_ARCH_ARMV7EMDP: 8,
        NATIVE_ARCH_XTENSA: 9,
        NATIVE_ARCH_XTENSAWIN: 10,
    }[name]


class Compiler:
    def mpy_version(self):
        """
        Get the version and sub-version of the .mpy file format generated by this compiler.

        Returns:
            A tuple of `(mpy_version, mpy_sub_version)`
        """
        raise NotImplementedError()

    def version(self):
        """
        Get the version string from this compiler.

        Returns:
            A string, typically "MicroPython <git tag> on <build date>".
        """
        raise NotImplementedError()

    def compile(
        self, src, dest=None, src_path=None, opt=0, march=NATIVE_ARCH_NONE, emit=EMIT_BYTECODE
    ):
        """
        Compile the specified .py file with mpy-cross.

        Args:
         - src (str):       The path to the .py file

        Keyword Arguments:
            dest (str):     The output .mpy file. Defaults to `src` (with .mpy extension)
            src_path (str): If provided, override the source file name embedded in the generated
                            .mpy file, otherwise use `src` for the file name.
            opt (int):      Optimisation level (0-3, default 0)
            march (int):    One of the `NATIVE_ARCH_*` constants (defaults to NATIVE_ARCH_NONE).
                            Architecture to use when generating code for @native/@viper functions.
            emit (int):     One of the `EMIT_*` constants (defaults to
                            EMIT_BYTECODE). This sets the default emitter to use for
                            functions that do not have a decorator.

        Returns:
            Standard output from mpy-cross as a string.
        """
        raise NotImplementedError()

    def description(self):
        """
        Returns:
            A string containing a description of this compiler.
        """
        raise NotImplementedError()

    def _find_binary(self, binary=None, name="mpy-cross", ext="", build_dir="build"):
        # If an explicit binary is given, use that.
        if binary and os.path.exists(binary):
            return binary

        # If we're running the installed version, then the binary will be
        # alongside the Python files.
        install_path = os.path.dirname(__file__)
        wheel_binary = os.path.abspath(os.path.join(install_path, name + ext))
        if os.path.exists(wheel_binary):
            return wheel_binary

        # Otherwise, running a locally-built copy, grab it from the build
        # directory.
        build_binary = os.path.abspath(os.path.join(install_path, "..", build_dir, name + ext))
        if os.path.exists(build_binary):
            return build_binary

        raise CompilerNotFoundError("Unable to find {}{} binary.".format(name, ext))


def default_compiler(binary=None):
    """
    Finds an available compiler.

    Keyword Arguments:
        binary (str): The path to a native or wasm binary. If this is specified then
                      no search will be performed, and only this binary will be tried.
    """

    if not binary or not binary.lower().endswith(".wasm"):
        try:
            from .compiler_native import CompilerNative

            return CompilerNative(binary=binary)
        except CompilerNotFoundError:
            pass

    if not binary or binary.lower().endswith(".wasm"):
        try:
            from .compiler_pywasm3 import CompilerPywasm3

            return CompilerPywasm3(binary=binary)
        except CompilerNotFoundError:
            pass

        try:
            from .compiler_wasmtime import CompilerWasmTime

            return CompilerWasmTime(binary=binary)
        except CompilerNotFoundError:
            pass

        try:
            from .compiler_wasmer import CompilerWasmer

            return CompilerWasmer(binary=binary)
        except CompilerNotFoundError:
            pass

    if binary:
        raise RuntimeError("Unable to instantiate compiler for {}.".format(binary))
    else:
        raise RuntimeError("No compiler installed/available.")
